---
timestamp: 'Mon Dec 01 2025 23:22:50 GMT-0500 (Eastern Standard Time)'
content_id: ab9d71e051afa12c72ca0b04862787568ceabcdab8dfc1d591bc04ffd864a0ad
---

# file: src/utils/spotify.ts

```typescript
import "jsr:@std/dotenv/load";

const CLIENT_ID = Deno.env.get("CLIENT_ID");
const CLIENT_SECRET = Deno.env.get("CLIENT_SECRET");

if (!CLIENT_ID || !CLIENT_SECRET) {
  throw new Error("CLIENT_ID and CLIENT_SECRET must be set in environment variables");
}

interface SpotifyTokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
}

interface SpotifySearchParams {
  query: string;
  type?: "track" | "album" | "artist" | "playlist" | string; // string allows comma-separated types like "track,album,artist"
  limit?: number;
  offset?: number;
}

/**
 * Spotify API Service
 * Handles authentication and API calls to Spotify Web API
 */
export class SpotifyService {
  private accessToken: string | null = null;
  private tokenExpiry: number = 0;

  /**
   * Get or refresh access token
   */
  private async getAccessToken(): Promise<string> {
    // Return cached token if still valid (with 5 minute buffer)
    if (this.accessToken && Date.now() < this.tokenExpiry - 300000) {
      return this.accessToken;
    }

    const authString = btoa(`${CLIENT_ID}:${CLIENT_SECRET}`);

    const response = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      body: new URLSearchParams({
        grant_type: "client_credentials",
      }),
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic " + authString,
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to get Spotify access token: ${response.statusText}`);
    }

    const data: SpotifyTokenResponse = await response.json();
    this.accessToken = data.access_token;
    this.tokenExpiry = Date.now() + data.expires_in * 1000;

    return this.accessToken;
  }

  /**
   * Search for tracks, albums, artists, or playlists
   */
  async search(params: SpotifySearchParams) {
    const accessToken = await this.getAccessToken();
    const type = params.type || "track";
    const limit = params.limit || 20;
    const offset = params.offset || 0;

    const url = new URL("https://api.spotify.com/v1/search");
    url.searchParams.set("q", params.query);
    url.searchParams.set("type", type);
    url.searchParams.set("limit", limit.toString());
    url.searchParams.set("offset", offset.toString());

    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Spotify API error: ${response.statusText}`);
    }

    return await response.json();
  }

  /**
   * Search for tracks (convenience method)
   */
  async searchTracks(query: string, limit: number = 20, offset: number = 0) {
    return await this.search({ query, type: "track", limit, offset });
  }

  /**
   * Search for a specific track by name and optionally artist
   * Uses Spotify's query syntax for more precise results
   * @example searchTrackByName("Need You Now", "Lady A")
   */
  async searchTrackByName(
    trackName: string,
    artistName?: string,
    limit: number = 20,
    offset: number = 0,
  ) {
    let query = `track:${trackName}`;
    if (artistName) {
      query += ` artist:${artistName}`;
    }
    return await this.search({ query, type: "track", limit, offset });
  }

  /**
   * Search for albums (convenience method)
   */
  async searchAlbums(query: string, limit: number = 20, offset: number = 0) {
    return await this.search({ query, type: "album", limit, offset });
  }

  /**
   * Search for artists (convenience method)
   */
  async searchArtists(query: string, limit: number = 20, offset: number = 0) {
    return await this.search({ query, type: "artist", limit, offset });
  }

  /**
   * Search across all types (tracks, albums, artists) simultaneously
   * Perfect for when you don't know what type of music the user is searching for
   * Uses quoted query for better exact phrase matching
   */
  async searchAll(
    query: string,
    limit: number = 20,
    offset: number = 0,
  ) {
    // Use quoted query for exact phrase matching, which improves relevance
    // This helps when users search for exact song/album/artist names
    const quotedQuery = query.includes('"') ? query : `"${query}"`;
    
    return await this.search({
      query: quotedQuery,
      type: "track,album,artist",
      limit,
      offset,
    });
  }

  /**
   * Smart search that tries multiple strategies for best results
   * 1. First tries exact phrase match (quoted)
   * 2. Falls back to general search if needed
   * Returns results from the most relevant search
   */
  async smartSearch(
    query: string,
    limit: number = 20,
    offset: number = 0,
  ) {
    // Strategy 1: Try exact phrase match first (best for specific names)
    const exactResults = await this.search({
      query: `"${query}"`,
      type: "track,album,artist",
      limit,
      offset,
    });

    // If we got good results (check if first result is highly relevant), return them
    // Otherwise, try a general search
    const hasGoodResults = 
      (exactResults.tracks?.items?.length > 0 && exactResults.tracks.items[0].name.toLowerCase().includes(query.toLowerCase().replace(/"/g, ''))) ||
      (exactResults.albums?.items?.length > 0 && exactResults.albums.items[0].name.toLowerCase().includes(query.toLowerCase().replace(/"/g, ''))) ||
      (exactResults.artists?.items?.length > 0 && exactResults.artists.items[0].name.toLowerCase().includes(query.toLowerCase().replace(/"/g, '')));

    if (hasGoodResults) {
      return exactResults;
    }

    // Strategy 2: Try general search (better for partial matches, trending content)
    return await this.search({
      query,
      type: "track,album,artist",
      limit,
      offset,
    });
  }

  /**
   * Get track information by ID
   */
  async getTrack(trackId: string) {
    const accessToken = await this.getAccessToken();

    const response = await fetch(
      `https://api.spotify.com/v1/tracks/${trackId}`,
      {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
        },
      },
    );

    if (!response.ok) {
      throw new Error(`Spotify API error: ${response.statusText}`);
    }

    return await response.json();
  }

  /**
   * Get album information by ID
   */
  async getAlbum(albumId: string) {
    const accessToken = await this.getAccessToken();

    const response = await fetch(
      `https://api.spotify.com/v1/albums/${albumId}`,
      {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
        },
      },
    );

    if (!response.ok) {
      throw new Error(`Spotify API error: ${response.statusText}`);
    }

    return await response.json();
  }

  /**
   * Get artist information by ID
   */
  async getArtist(artistId: string) {
    const accessToken = await this.getAccessToken();

    const response = await fetch(
      `https://api.spotify.com/v1/artists/${artistId}`,
      {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
        },
      },
    );

    if (!response.ok) {
      throw new Error(`Spotify API error: ${response.statusText}`);
    }

    return await response.json();
  }

  /**
   * Get album tracks by album ID
   * @see https://developer.spotify.com/documentation/web-api/reference/get-an-albums-tracks
   */
  async getAlbumTracks(
    albumId: string,
    options?: { market?: string; limit?: number; offset?: number },
  ) {
    const accessToken = await this.getAccessToken();
    const limit = options?.limit || 20;
    const offset = options?.offset || 0;

    const url = new URL(`https://api.spotify.com/v1/albums/${albumId}/tracks`);
    if (options?.market) {
      url.searchParams.set("market", options.market);
    }
    url.searchParams.set("limit", limit.toString());
    url.searchParams.set("offset", offset.toString());

    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Spotify API error: ${response.statusText}`);
    }

    return await response.json();
  }

  /**
   * Get an artist's albums
   * @see https://developer.spotify.com/documentation/web-api/reference/get-an-artists-albums
   */
  async getArtistAlbums(
    artistId: string,
    options?: { include_groups?: string; market?: string; limit?: number; offset?: number },
  ) {
    const accessToken = await this.getAccessToken();
    const limit = options?.limit || 20;
    const offset = options?.offset || 0;
    const includeGroups = options?.include_groups || "album,single,compilation,appears_on";

    const url = new URL(`https://api.spotify.com/v1/artists/${artistId}/albums`);
    url.searchParams.set("include_groups", includeGroups);
    if (options?.market) {
      url.searchParams.set("market", options.market);
    }
    url.searchParams.set("limit", limit.toString());
    url.searchParams.set("offset", offset.toString());

    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Spotify API error: ${response.statusText}`);
    }

    return await response.json();
  }
}

// Export a singleton instance
export const spotifyService = new SpotifyService();

// Example Spotify Service Calls

// For specific track searches, use searchTrackByName with artist name for better results
spotifyService.searchTrackByName("Need You Now", undefined, 10).then(found_tracks => {
  console.log("Found song:");
  console.log(found_tracks.tracks.items[0].name, "by", found_tracks.tracks.items[0].artists[0].name);
  console.log("Spotify URL:", found_tracks.tracks.items[0].external_urls.spotify);
  console.log("URI:", found_tracks.tracks.items[0].uri);
  // console.log(found_tracks)
}).catch(error => {
  console.error("Test failed:", error);
});

// For general searches (when you don't know the exact track/artist), use searchAll
// spotifyService.searchAll("Need You Now", 10).then(found_tracks => {
//   console.log("Found song:");
//   console.log(found_tracks.tracks.items[0].name, "by", found_tracks.tracks.items[0].artists[0].name);
//   console.log("Spotify URL:", found_tracks.tracks.items[0].external_urls.spotify);
//   console.log("URI:", found_tracks.tracks.items[0].uri);
// }).catch(error => {
//   console.error("Test failed:", error);
// });

spotifyService.searchAlbums("need you now lady a").then(async (found_albums) => {
  console.log("Found album:");
  console.log(found_albums.albums.items[0].name, "by", found_albums.albums.items[0].artists[0].name);
  console.log("Artist URI:", found_albums.albums.items[0].artists[0].uri);
  console.log("Album URI:", found_albums.albums.items[0].uri);
  const artist_id = found_albums.albums.items[0].artists[0].id;
  // console.log("Artist Albums:", await spotifyService.getArtistAlbums(artist_id));
})
// spotifyService.getAlbumTracks(await lux).then(found_tracks => {
//   for (const track of found_tracks.items) {
//     console.log("track:");
//     console.log(track.name, "by", track.artists[0].name);
//     console.log("Spotify URL:", track.external_urls.spotify);
//     console.log("URI:", track.uri);
//   }
// })

```
